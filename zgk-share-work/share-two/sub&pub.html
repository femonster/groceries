<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>订阅/发布模式</title>
</head>
<!-- 
	订阅/发布模式（观察者模式）定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象

	发布者发出通知 => 主题对象收到通知并推送给订阅者 => 订阅者执行相应操作
 -->
<body>

</body>
<!-- <script>
	//一个发布者
	var pub = {
		publish:function() {
			dep.notify();
		}
	}
	//三个订阅者
	var sub1 = { update:function () {console.log(1)} };
	var sub2 = { update:function () {console.log(2)} };
	var sub3 = { update:function () {console.log(3)} };

	//一个主题对象
	function Dep(){
		this.subs = [sub1,sub2,sub3];
	} 

	Dep.prototype.notify = function () {
		this.subs.forEach(function (sub) {
			sub.update();
		})
	}

	//发布者发布消息，主题对象执行notify方法，进而触发订阅者执行update方法
	var dep = new Dep();
	pub.publish();
</script> -->
<!-- 
	观察者对象：
		一个消息容器
		三个方法：订阅消息方法
		          取消订阅的消息方法
		          发送订阅的消息方法
 -->

<script>
	var Observer = (function() {
		var _messages = {};
		return {
			//注册信息接口
			//prams 消息类型以及相应的处理动作
			regist:function (type,fn) {
				//如果此消息不存在则应该创建一个该消息类型
				if (typeof _messages[type] === 'undefined') {
					_messages[type] = [fn];
				//如果存在
				}else{
					_messages[type].push(fn);
				}
			},
			//发布信息接口
			fire:function (type,args) {
				//如果该消息没有被注册，则返回
				if(!_messages[type]) return;
				//定义消息信息
				var events = {
					type:type,
					args:args || {}
				},
				i = 0,
				len = _messages[type].length;
				//遍历消息动作
				for (; i < len; i++) {
					_messages[type][i].call(this,events);
				}
			},
			//移除信息接口
			remove:function (type,fn) {
				//如果消息动作队列存在
				if (_messages[type] instanceof Array) {
					var i = _messages[type].length - 1;
					for (; i >= 0; i--) {
						_messages[types][i] === fn && _messages[type].splice(i,1);
					}
				}
			}
		}
	})();

	Observer.regist('test',function (e) {
		console.log(e.type,e.args.msg);
	})

	Observer.fire('test',{msg:'传递参数'});
</script>
</html>